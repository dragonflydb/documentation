[
  {
    "slug": "incrbyfloat",
    "title": "INCRBYFLOAT",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `INCRBYFLOAT` command is used to increment the value of a key by a specified floating-point number.\nThis command is particularly useful when you need to store numerical data and perform frequent updates with floating-point precision, such as tracking scores, balances, or statistics.\n\nIf the key does not exist, `INCRBYFLOAT` will initialize it to `0` before executing the operation.\n\n## Syntax\n\n```shell\nINCRBYFLOAT key increment\n```\n\n## Parameter Explanations\n\n- `key`: The key where the number is stored.\n- `increment`: The floating-point number by which to increment the value.\n\n## Return Values\n\n- The command returns the new floating-point value after the increment.\n\n## Code Examples\n\n### Basic Example\n\nIncrement the float value of a key:\n\n```shell\ndragonfly> SET counter 10.5\nOK\ndragonfly> INCRBYFLOAT counter 1.5\n\"12\"\n```\n\nHere, the value stored at `counter` is updated from `10.5` to `12` after adding `1.5`.\n\n### Initializing and Incrementing Non-Existent Keys\n\nIf the key does not exist, it is initialized to `0` before incrementing by the specified amount.\n\n```shell\n\ndragonfly> INCRBYFLOAT new_counter 2.5\n\"2.5\"\n```\n\n### Negative Floating-Point Increments\n\nYou can also use negative numbers to decrement the value:\n\n```shell\ndragonfly> SET score 20.0\nOK\ndragonfly> INCRBYFLOAT score -5.5\n\"14.5\"\n```\n\n### Handling High Precision Increments\n\n`INCRBYFLOAT` maintains float precision, allowing fine-grained changes, such as adding a small decimal value:\n\n```shell\ndragonfly> SET balance 150.0\nOK\ndragonfly> INCRBYFLOAT balance 0.03\n\"150.03\"\n```\n\n### Multiple Increments on the Same Key\n\nYou can repeatedly increment the same key for cumulative updates:\n\n```shell\ndragonfly> SET total 100.0\nOK\ndragonfly> INCRBYFLOAT total 10.7\n\"110.7\"\ndragonfly> INCRBYFLOAT total 2.3\n\"113\"\n```\n\n## Best Practices\n\n- Use `INCRBYFLOAT` when you need arithmetic operations that require floating-point precision.\n- Be cautious when performing many small floating-point increments, as precision drift might occur over time.\n- Consider using this command for tracking metrics or scores where floating-point precision is essential.\n\n## Common Mistakes\n\n- Incrementing non-numeric values can throw an error, so always ensure the stored value is a valid number (or numeric string).\n- Be aware that rounding errors are inherent to floating-point arithmetic, so the result might not have perfect precision for certain values.\n\n## FAQs\n\n### What happens if the key stores a non-numeric value?\n\nIf the key holds a non-numeric value, `INCRBYFLOAT` returns an error indicating that the value cannot be incremented.\n\n### Can I decrement a number using `INCRBYFLOAT`?\n\nYes, providing a negative increment will effectively decrement the current value.\n\n### Does `INCRBYFLOAT` work with integers?\n\nWhile `INCRBYFLOAT` is designed for floating-point numbers, it can increment integer values as well. However, the result will always be returned as a floating-point number.",
    "tag": "Redis"
  },
  {
    "slug": "getdel",
    "title": "GETDEL COMMAND IN DRAGONFLY",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `GETDEL` command is used to retrieve the value of a key and simultaneously delete that key from the database.\nThis atomically combines two operations — one to get the value of the key, and another to remove the key — making it more efficient than running the individual `GET` and `DEL` commands in sequence.\n\n## Syntax\n\n```shell\nGETDEL key\n```\n\n## Parameter Explanations\n\n- `key`: The key of the value you want to retrieve and delete.\n\n## Return Values\n\nThe command returns the value stored at the given key if the key exists.\nIf the key does not exist, `nil` is returned.\nAfter the operation, the key is guaranteed to be deleted from the database.\n\n## Code Examples\n\n### Basic Example\n\nRetrieve the value and delete the key:\n\n```shell\ndragonfly> SET mykey \"Hello, Dragonfly!\"\nOK\n\ndragonfly> GETDEL mykey\n\"Hello, Dragonfly!\"\n\ndragonfly> GET mykey\n(nil)\n```\n\nIn this example, the value `\"Hello, Dragonfly!\"` is returned by `GETDEL` and the `mykey` is deleted from the database, as verified by the subsequent `GET`.\n\n### Retrieving and Deleting a Non-Existent Key\n\nIf the key does not exist, `GETDEL` will return `nil` without throwing an error:\n\n```shell\ndragonfly> GETDEL nonexistent_key\n(nil)\n```\n\nSince `nonexistent_key` does not exist, the return is `nil`, and no other action is taken.\n\n### Multiple Operations in Parallel\n\nIf you operate on the same key with `GETDEL` and try to access it in parallel, the following result can occur:\n\n```shell\ndragonfly> SET anotherkey \"Goodbye\"\nOK\n\ndragonfly> GETDEL anotherkey\n\"Goodbye\"\n\ndragonfly> GET anotherkey\n(nil)\n```\n\nThis ensures that both the retrieval and deletion occur atomically, confirming the key is no longer in the database afterward.\n\n## Best Practices\n\n- Use `GETDEL` when you want to both retrieve a value and delete the key in a single atomic operation, especially in scenarios where performing these two actions separately may introduce race conditions.\n- This operation is particularly helpful in cases like caching systems where you want to retrieve and invalidate cached values instantly.\n\n## Common Mistakes\n\n- Forgetting that after calling `GETDEL`, the key will no longer exist.\n  If subsequent operations depend on the key being available, you might need to handle it differently.\n- Assuming `GETDEL` will work on non-string data types like hashes, lists, or sets.\n  `GETDEL` only works on keys storing simple string values.\n\n## FAQs\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `GETDEL` returns `nil`, and no other action is performed.\n\n### Can `GETDEL` operate on non-string data types?\n\nNo, `GETDEL` is intended for string keys only.\nIf you attempt to use it on a non-string type, an error will be generated.\nFor retrieving and deleting non-string data types, you will need to use other Redis commands.\n\n## Conclusion\n\n`GETDEL` offers an efficient and atomic approach when retrieving and deleting a key simultaneously.\nIt simplifies your operations when you need to get a key's value and immediately remove it from the database.",
    "tag": "Redis"
  },
  {
    "slug": "getbit",
    "title": "GETBIT",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `GETBIT` command is used to retrieve the bit value (either `0` or `1`) at a specific position in a string.\nThe command allows you to efficiently access individual bits stored in a string, making it particularly useful for scenarios such as bitwise operations, feature flags, or binary statuses.\n\n## Syntax\n\n```shell\nGETBIT key offset\n```\n\n## Parameter Explanations\n\n- `key`: The key of the string holding the value where the bit is extracted.\n- `offset`: The bit offset (zero-based index) to retrieve from. The first bit of the string is at offset `0`.\n\n## Return Values\n\nThe command will return either `0` or `1`, corresponding to the bit value at the specified `offset`.\nIf the `offset` exceeds the length of the string (in bits), the command returns `0`.\n\n## Code Examples\n\n### Basic Example\n\nRetrieve a bit at a specific position in a string:\n\n```shell\n# String: example\n# Hex:    0x65     0x78     0x61     0x6d     0x70     0x6c     0x65\n# Binary: 01100101 01111000 01100001 01101101 01110000 01101100 01100101\ndragonfly> SET mykey \"example\"\nOK\ndragonfly> GETBIT mykey 1\n(integer) 1  # The bit at position 1 is 1.\ndragonfly> GETBIT mykey 6\n(integer) 0  # The bit at position 6 is 0.\n```\n\n### Retrieving Bits Beyond the String Boundaries\n\nAttempting to retrieve a bit beyond the length of the string:\n\n```shell\n# The length of the string \"example\" in bits is 56 (7 characters * 8 bits).\ndragonfly> GETBIT mykey 100\n(integer) 0  # Returns 0 because the offset is out of bounds.\n```\n\n### Using `GETBIT` in Binary Flags\n\nIn many use cases, each bit can signify a flag that is either enabled (`1`) or disabled (`0`):\n\n```shell\ndragonfly> SET flags \"\\x0F\"  # Binary: 00001111 (four flags enabled)\nOK\ndragonfly> GETBIT flags 0\n(integer) 0  # First feature is disabled.\ndragonfly> GETBIT flags 3\n(integer) 1  # Fourth feature is enabled.\n```\n\n## Best Practices\n\n- Consider compressing binary representations of data into strings and using `GETBIT` to check for specific flags or states.\n- If you manage performance-sensitive applications, long strings should be accessed cautiously to avoid performance bottlenecks due to large bit offset calculations.\n\n## Common Mistakes\n\n- Using byte-level offsets when specifying the `offset` for `GETBIT`. The `offset` parameter works at the bit level, not at the byte level.\n- Assuming that `GETBIT` modifies the string. This command only reads the specified bit without altering the string.\n\n## FAQs\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `GETBIT` returns `0` by default, as there is no bit set at any offset.\n\n### Can I use negative offsets?\n\nNo, the `GETBIT` command does not support negative offsets. You must provide a non-negative integer.",
    "tag": "Redis"
  },
  {
    "slug": "incrby",
    "title": "INCRBY",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `INCRBY` command allows you to increment the value of a key by a specified integer amount.\nThis is particularly useful when working with counters or any numerical values that need to be incremented atomically.\nIf the key does not exist, `INCRBY` will create the key with an initial value of `0` before performing the increment operation.\n\n## Syntax\n\n```shell\nINCRBY key increment\n```\n\n## Parameter Explanations\n\n- `key`: The name of the key whose value you want to increment.\n- `increment`: The integer amount by which to increment the current value at the key.\n\n## Return Values\n\nThe command returns the new value of the key, which is the result of adding the specified increment to the current value.\n\n## Code Examples\n\n### Basic Example\n\nIncrement a key by `5`:\n\n```shell\ndragonfly> SET mycounter 10\nOK\ndragonfly> INCRBY mycounter 5\n(integer) 15\n```\n\nIn this example, the value of `mycounter` is initially `10`, and after executing `INCRBY mycounter 5`, the new value becomes `15`.\n\n### Increment a Non-Existent Key\n\nIf the key does not exist, `INCRBY` will first set it to `0` and then increment it by the specified value:\n\n```shell\n\ndragonfly> INCRBY newcounter 4\n(integer) 4\n```\n\nHere, `newcounter` did not exist initially. \n`INCRBY` creates the key and sets its value to `4` as there was no existing value to increment.\n\n### Using Negative Increments\n\nYou can also decrement a key by passing a negative number as the increment value:\n\n```shell\ndragonfly> SET score 20\nOK\ndragonfly> INCRBY score -7\n(integer) 13\n```\n\nIn this example, `INCRBY` is used with a negative value of `-7` to decrement the key `score` from `20` to `13`.\n\n### Multiple Increments\n\nIncrement the same key multiple times with different values:\n\n```shell\ndragonfly> SET visits 100\nOK\ndragonfly> INCRBY visits 10\n(integer) 110\ndragonfly> INCRBY visits 15\n(integer) 125\n```\n\nHere, the value of `visits` is incremented twice, first by `10` and then by `15`, resulting in a final value of `125`.\n\n## Best Practices\n\n- Use `INCRBY` for maintaining counters or other numeric accumulations that need to be updated atomically.\n- Keep in mind that if you are dealing with non-integer values, this command does not support floating-point numbers. \n  For floats, use `INCRBYFLOAT` instead.\n\n## Common Mistakes\n\n- Applying `INCRBY` to a key that holds a non-integer value will result in an error.\n  Ensure that the key either contains an integer or does not exist when using this command.\n  \n- Using `INCRBY` with a key that stores a non-numeric value will cause an error and fail:\n  \n```shell\ndragonfly> SET mystring \"hello\"\nOK\ndragonfly> INCRBY mystring 2\n(error) ERR value is not an integer or out of range\n```\n\n- Trying to increment large numerical values that exceed the 64-bit signed integer limit may result in an overflow error.\n\n## FAQs\n\n### What happens if the key holds a string value instead of an integer?\n\nIf the key holds a string, list, or another non-integer value, `INCRBY` will return an error. \nThe key must either be unset or holding an integer value to execute successfully.\n\n### Can I use `INCRBY` with floating-point numbers?\n\nNo, `INCRBY` only works with integers. \nIf you need to increment by a floating-point number, you should use the `INCRBYFLOAT` command.\n\n### What’s the maximum increment value I can use?\n\n`INCRBY` supports 64-bit signed integers. \nAs such, the maximum allowable increment would be `9,223,372,036,854,775,807`, and the minimum would be `-9,223,372,036,854,775,808`.",
    "tag": "Redis"
  },
  {
    "slug": "getex",
    "title": "GETEX",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `GETEX` command is used to get the value of a key and set a new expiration time in the same operation.\nThis can be useful when you want to access the current value of a key but also update how long that key will live before automatically being removed from your database.\n\n## Syntax\n\n```shell\nGETEX key [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|PERSIST]\n```\n\n## Parameter Explanations\n\n- `key`: The key for which the value is to be retrieved and an expiration set.\n- `EX seconds`: Set the key to expire in `seconds`.\n- `PX milliseconds`: Set the key to expire in `milliseconds`.\n- `EXAT timestamp`: Set the key to expire at a specific UNIX timestamp (in seconds).\n- `PXAT milliseconds-timestamp`: Set the key to expire at a specific UNIX timestamp (in milliseconds).\n- `PERSIST`: Remove the expiration from the key, making it persistent.\n\n## Return Values\n\nThe command returns the current value of the key being requested before the expiration is updated.\n\nIf the key does not exist, `GETEX` returns `nil`.\n\n## Code Examples\n\n### Basic Example\n\nGet the current value of a key and set a new TTL (in seconds):\n\n```shell\n\ndragonfly> SET mykey \"hello\" EX 3600\nOK\ndragonfly> GETEX mykey EX 1200\n\"hello\"\n```\n\nIn this example, we first set the value (`\"hello\"`) to the key `mykey` with a TTL of one hour (3600 seconds).\nThen, we retrieve the value with `GETEX` and update the TTL to 1200 seconds (20 minutes).\n\n### Using Milliseconds for Expiration\n\nSet the expiration time in milliseconds:\n\n```shell\n\ndragonfly> SET mykey \"data\"\nOK\ndragonfly> GETEX mykey PX 15000\n\"data\"\n```\n\nHere, the key `mykey` has its value retrieved (`\"data\"`) while the expiration time is updated to 15,000 milliseconds (15 seconds).\n\n### Setting Expiration at a Specific UNIX Timestamp\n\nSet an expiration using a UNIX timestamp in seconds:\n\n```shell\n\ndragonfly> SET report \"yearly\"\nOK\ndragonfly> GETEX report EXAT 1699999999\n\"yearly\"\n```\n\nIn this case, the key `report` is set to expire at the specified UNIX timestamp (`1699999999`), while we retrieve its current value.\n\n### Removing Expiration Using `PERSIST`\n\nRemove the key's expiration:\n\n```shell\n\ndragonfly> SET session \"active\" EX 1800\nOK\ndragonfly> GETEX session PERSIST\n\"active\"\n```\n\nHere, the key `session` had an expiration of 30 minutes, but with `GETEX ... PERSIST`, we not only retrieve the value but also make the key persistent, removing its expiration.\n\n## Best Practices\n\n- Use `GETEX` when you need to read a key's value and update its expiration simultaneously.\n- To optimize storage cleanup, prefer the use of UNIX timestamp options (`EXAT` or `PXAT`) for setting expiration when a precise expiration is required.\n  \n## Common Mistakes\n\n- Using `GETEX` on non-existent keys will return `nil`, potentially causing confusion if you're not accounting for the absence of the key.\n- Misunderstanding expiration is set *before* the value is returned; the expiration might cause a race condition if another command modifies the key before the TTL updates.\n\n## FAQs\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `GETEX` will return `nil` and no expiration will be set.\n\n### Does `GETEX` alter the value of the key?\n\nNo, `GETEX` only retrieves the value and optionally changes the TTL.\nThe value stored in the key remains unchanged unless modified by other commands.",
    "tag": "Redis"
  },
  {
    "slug": "mget",
    "title": "MGET",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `MGET` command is used to retrieve the values of multiple keys in a single request.\nIt simplifies fetching values from several keys at once, making it highly efficient for batch retrieval.\nIf a key does not exist, `MGET` returns `nil` for that key instead of an error.\n\n## Syntax\n\n```shell\nMGET key [key ...]\n```\n\n## Parameter Explanations\n\n- `key`: The key(s) whose values you want to retrieve.\n  You can specify multiple keys, and their values will be retrieved in the order they were provided.\n\n## Return Values\n\nThe command returns an array of values corresponding to the list of keys.\nIf a key does not exist, `nil` is returned for that particular key.\n\n## Code Examples\n\n### Basic Example: Retrieving Multiple Keys\n\nRetrieve values from multiple keys:\n\n```shell\ndragonfly> SET key1 \"value1\"\nOK\ndragonfly> SET key2 \"value2\"\nOK\ndragonfly> SET key3 \"value3\"\nOK\ndragonfly> MGET key1 key2 key3\n1) \"value1\"\n2) \"value2\"\n3) \"value3\"\n```\n\n### When Some Keys Do Not Exist\n\nIf one or more keys do not exist, `MGET` will return `nil` for the missing keys:\n\n```shell\ndragonfly> MGET key1 key_non_existent key3\n1) \"value1\"\n2) (nil)\n3) \"value3\"\n```\n\n### Using `MGET` for Bulk Retrieval\n\nIn scenarios where you are managing session data for multiple users, you can use `MGET` to efficiently retrieve their session information in one operation:\n\n```shell\ndragonfly> SET session:user1 \"data1\"\nOK\ndragonfly> SET session:user2 \"data2\"\nOK\ndragonfly> SET session:user3 \"data3\"\nOK\ndragonfly> MGET session:user1 session:user2 session:user3\n1) \"data1\"\n2) \"data2\"\n3) \"data3\"\n```\n\n### Example with Keys that Expire\n\nIf some of the keys have expired or are nearing expiration, `MGET` will still retrieve available keys but return `nil` for those that no longer exist:\n\n```shell\ndragonfly> SET key_expiring \"temp_value\" EX 1  # Expires in 1 second\nOK\ndragonfly> SET key_persistent \"persistent_value\"\nOK\ndragonfly> MGET key_expiring key_persistent\n1) \"temp_value\"\n2) \"persistent_value\"\n\n# After 1 second\ndragonfly> MGET key_expiring key_persistent\n1) (nil)\n2) \"persistent_value\"\n```\n\n## Best Practices\n\n- Use `MGET` to minimize network round trips when retrieving values from multiple keys at once.\n- Combine keys logically when possible to facilitate batch retrieval, which can significantly improve application performance.\n- If some keys are expected to frequently expire, account for `nil` values in the application logic to avoid unnecessary errors.\n\n## Common Mistakes\n\n- Forgetting that `MGET` doesn't throw an error if keys don't exist, which might lead to unexpected `nil` values in the returned results.\n- Assuming `MGET` will throw an exception for expired or missing keys—it silently returns `nil` for those keys instead.\n- Not handling possible `nil` results when operating on keys subject to expiration.\n\n## FAQs\n\n### Does `MGET` return an error if one of the keys does not exist?\n\nNo, if one or more keys do not exist or have expired, `MGET` returns `nil` for those keys without throwing an error.\n\n### Can I use `MGET` with binary data?\n\nYes, `MGET` works with binary strings, just as it does with normal strings.\nIt can retrieve any data stored in a binary-safe manner.\n\n### Is there a limit to how many keys I can fetch using `MGET`?\n\nThere isn't a strict limit enforced by Dragonfly, Redis, or Valkey, though practical limitations such as memory or maximum payload size may apply based on available system resources.",
    "tag": "Redis"
  },
  {
    "slug": "getset",
    "title": "GETSET",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `GETSET` command is used to atomically set a key to a new string value and return its old string value.\nThis command is useful when you need to replace a value but also want to keep track of the previous value before overwriting it, making it an atomic and efficient way to perform this operation.\n\n## Syntax\n\n```shell\nGETSET key value\n```\n\n## Parameter Explanations\n\n- `key`: The key whose value should be replaced.\n- `value`: The new value to set the key to.\n\n## Return Values\n\nThe command returns the old value that was stored at the key before it was set to the new value.\nIf the key did not exist, it returns `nil`.\n\n## Code Examples\n\n### Basic Example\n\nSet a key to a new value and retrieve the old value:\n\n```shell\ndragonfly> SET mykey \"old_value\"\nOK\ndragonfly> GETSET mykey \"new_value\"\n\"old_value\"\n```\n\nIf the key does not exist yet, `GETSET` will return `nil`:\n\n```shell\ndragonfly> GETSET mykey2 \"first_value\"\n(nil)\n```\n\n### Using `GETSET` for Atomic Value Updates\n\nThis command is particularly useful when you want to update a key's value atomically while preserving the old value for further use or inspection:\n\n```shell\n# User balance system where balance is first saved, then updated atomically\ndragonfly> SET balance \"100\"\nOK\ndragonfly> GETSET balance \"200\"\n\"100\"  # Old balance\ndragonfly> GET balance\n\"200\"  # New balance\n```\n\n### `GETSET` in Cache Systems\n\nIn cache systems, `GETSET` is great for refreshing stale values atomically:\n\n```shell\n# Set initial cache value\ndragonfly> SET cache_item \"stale_value\"\nOK\n\n# Atomically refresh the cache with a new value, returning the old one\ndragonfly> GETSET cache_item \"fresh_value\"\n\"stale_value\"\n\n# Verify that the value has been updated\ndragonfly> GET cache_item\n\"fresh_value\"\n```\n\n## Best Practices\n\n- Use `GETSET` when you need atomicity in replacing a value and retrieving the previous one.\n- Be cautious when using `GETSET` in high-write workloads, as it can be slower than using `SET` on its own, due to the need to return the old value.\n\n## Common Mistakes\n\n- Trying to use `GETSET` on non-string values like lists, sets, or hashes; it only works on string values.\n- Assuming that it will return something other than `nil` for non-existent keys.\n\n## FAQs\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `GETSET` will return `nil` and set the key to the new value.\n\n### Can `GETSET` be used with non-string values such as lists or sets?\n\nNo, `GETSET` only works with string values.\nFor non-string data types, consider using other commands like `LINDEX` for lists or `HGETSET` for hashes.\n\n### Is `GETSET` atomic?\n\nYes, `GETSET` is atomic, meaning it safely sets the new value and retrieves the old value in one single operation.\nThis helps avoid race conditions in concurrent environments.",
    "tag": "Redis"
  },
  {
    "slug": "mset",
    "title": "MSET",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `MSET` command is used to set multiple key-value pairs atomically in a single operation.\nThis means that either all the keys are set or none of them are, ensuring consistency across a set of operations.\n\nThe `MSET` command is a more efficient way to set multiple keys when compared to multiple calls to `SET`, as it minimizes the number of requests made to the database.\n\n## Syntax\n\n```shell\nMSET key value [key value ...]\n```\n\n## Parameter Explanations\n\n- `key`: The key to be set.\n- `value`: The value to associate with the key.\n- You can input multiple key-value pairs by repeating this `[key value]` pattern.\n\n## Return Values\n\nThe `MSET` command always returns `OK` regardless of whether the keys already exist or not.\nIt will overwrite any existing keys with the provided values.\n\n## Code Examples\n\n### Basic Example\n\nSet multiple key-value pairs:\n\n```shell\ndragonfly> MSET key1 \"value1\" key2 \"value2\" key3 \"value3\"\nOK\ndragonfly> GET key1\n\"value1\"\ndragonfly> GET key2\n\"value2\"\ndragonfly> GET key3\n\"value3\"\n```\n\n### Overwriting Existing Keys\n\nIf any of the specified keys already exist, `MSET` will overwrite them:\n\n```shell\ndragonfly> SET key1 \"initial\"\nOK\ndragonfly> MSET key1 \"new_value\" key2 \"additional_value\"\nOK\ndragonfly> GET key1\n\"new_value\"\ndragonfly> GET key2\n\"additional_value\"\n```\n\n### Atomic Operations with `MSET`\n\nThe atomic nature of the `MSET` command ensures that all keys are set together, providing consistency across values even in concurrent situations:\n\n```shell\ndragonfly> MSET key1 \"first_value\" key2 \"second_value\" key3 \"third_value\"\nOK\n\n# Elsewhere (in another connection or thread), the atomicity ensures these values are set together.\ndragonfly> MGET key1 key2 key3\n1) \"first_value\"\n2) \"second_value\"\n3) \"third_value\"\n```\n\n## Best Practices\n\n- Use `MSET` when you need to update multiple keys at once, as it's more efficient than separate `SET` commands.\n- Since `MSET` performs overwrite operations, ensure that overwriting values is intended in your use case.\n\n## Common Mistakes\n\n- Mixing up key-value pairs: Ensure that the number of arguments passed to `MSET` is even (each key must have a corresponding value).\n- Assuming `MSET` will fail if any of the keys already exist; in fact, it does not check whether a key exists and will always overwrite the value.\n\n## FAQs\n\n### What happens if one of the keys already exists?\n\n`MSET` will overwrite any existing key. It does not perform checks for existing values and does not provide a conditional setting mechanism.\n\n### Can I use `MSET` without arguments?\n\nNo, you must provide at least one key-value pair. If the total number of arguments is not even, you will get a syntax error.\n\n### How does `MSET` differ from `SET`?\n\nWhile `SET` sets a single key-value pair, `MSET` allows you to set multiple key-value pairs in one atomic operation, which can be more efficient in batch updates.",
    "tag": "Redis"
  },
  {
    "slug": "getrange",
    "title": "GETRANGE COMMAND IN DRAGONFLY, REDIS, AND VALKEY",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `GETRANGE` command is used to retrieve a substring from a string stored at a specific key.\nIt allows you to extract characters from the stored string by specifying the starting and ending offsets (inclusive).\nThis is a useful tool when you want portions of a string without fetching the entire value.\n\n## Syntax\n\n```shell\nGETRANGE key start end\n```\n\n## Parameter Explanations\n\n- `key`: The key that holds the string from which you want to extract a substring.\n- `start`: The starting character position (zero-based index) in the string.\n- `end`: The ending character position (inclusive) for the substring, or `-1` to refer to the last character.\n\n## Return Values\n\nThe command returns the specified substring extracted from the string value stored at the specified key.\n\n## Code Examples\n\n### Basic Example\n\nRetrieve a substring from a stored string:\n\n```shell\ndragonfly> SET mykey \"example\"\nOK\ndragonfly> GETRANGE mykey 0 2\n\"exa\"\n```\n\nIn the above example, the substring \"exa\" is returned as it starts from index `0` and ends at index `2`.\n\n### Extract Substring Using Negative Index\n\nYou can use negative numbers to address characters starting from the end:\n\n```shell\ndragonfly> SET mykey \"example\"\nOK\ndragonfly> GETRANGE mykey -4 -1\n\"mple\"\n```\n\nIn this case, `-4` refers to the fourth character from the end, and `-1` refers to the last character.\n\n### Extract a Substring in a Range That Does Not Fully Exist\n\nIf the given range exceeds the string's length, the command will still return what is available:\n\n```shell\ndragonfly> SET mykey \"example\"\nOK\ndragonfly> GETRANGE mykey 5 50\n\"ple\"\n```\n\nHere, although the ending index is beyond the actual string length, Dragonfly returns up to the last available characters, which is \"ple.\"\n\n### Use Case for Handling Large Strings\n\nFor user data like URLs, session identifiers, or logs, you may want to extract meaningful segments without loading the entire dataset:\n\n```shell\ndragonfly> SET logentry \"ErrorCode:404,Page:/about,Message:Not Found,ClientIP:192.168.1.50\"\nOK\ndragonfly> GETRANGE logentry 11 24\n\"404,Page:/about\"\n```\n\nThis allows you to fetch specific parts of user data efficiently.\n\n## Best Practices\n\n- Use `GETRANGE` when dealing with large strings to minimize memory consumption and bandwidth by fetching only what you need.\n- Negative indices are a powerful feature but ensure that they accurately reflect the part of the string you're interested in.\n\n## Common Mistakes\n\n- Providing out-of-bound indexes does not throw an error, but can lead to unexpected results. Make sure your range matches the string structure.\n- Confusing character positions with byte positions in certain cases, especially with non-ASCII data, may lead to inaccuracies.\n\n## FAQs\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `GETRANGE` will return an empty string.\n\n### How does `GETRANGE` handle encoding?\n\n`GETRANGE` operates at the character level for ASCII-compatible encoding, but with multibyte encodings (like UTF-8), ranges refer to byte positions rather than actual characters.\n\n### Can I use `GETRANGE` on binary data?\n\nYes, `GETRANGE` works on strings, whether they are text or binary. The start and end positions relate to bytes when dealing with binary data.",
    "tag": "Redis"
  },
  {
    "slug": "incr",
    "title": "INCR",
    "content": "## Introduction\n\nIn Dragonfly, as well as in Redis and Valkey, the `INCR` command is used to atomically increment the integer value of a key by one. \nThis is helpful for implementing counters, tracking requests, or managing sequence numbers since it is thread-safe and operates in constant time `O(1)`.\n\n## Syntax\n\n```shell\nINCR key\n```\n\n## Parameter Explanations\n\n- `key`: The key whose value will be incremented by one. If the key doesn't exist, it will be automatically created with a value of `0` before being incremented.\n\n## Return Values\n\nReturns the new value of the key after the increment as an integer.\n\n## Code Examples\n\n### Basic Example\n\nIncrement an integer stored in a key:\n\n```shell\ndragonfly> SET mykey 10\nOK\ndragonfly> INCR mykey\n(integer) 11\n```\n\n### Automatically Creating and Incrementing a Key\n\nIf the key does not exist, `INCR` will set it to `0` before incrementing it:\n\n```shell\ndragonfly> EXISTS counter\n(integer) 0\ndragonfly> INCR counter\n(integer) 1\n```\n\n### Using `INCR` with Negative Numbers\n\n`INCR` can handle negative numbers too. \nIt will still increase the value by one in this case:\n\n```shell\ndragonfly> SET mykey -5\nOK\ndragonfly> INCR mykey\n(integer) -4\n```\n\n### Incrementing in a Loop\n\nYou can repeatedly call `INCR` to track a counter of operations:\n\n```shell\ndragonfly> SET request_count 100\nOK\ndragonfly> INCR request_count\n(integer) 101\ndragonfly> INCR request_count\n(integer) 102\n```\n\n## Best Practices\n\n- Use `INCR` to implement performance-efficient counters due to its atomic nature.\n- Consider using the `EXPIRE` command alongside to set TTLs for temporary counters, such as tracking hits in a web application.\n- If you need to increment a value by something other than `1`, use the closely related `INCRBY` command, which allows you to specify the increment amount.\n  \n## Common Mistakes\n\n- Trying to use `INCR` on non-integer or non-string values (e.g., lists or sets). \n  This will result in an error, as `INCR` expects the value stored at `key` to be a string representation of an integer.\n  \n  ```shell\n  dragonfly> LPUSH mylist 1\n  (integer) 1\n  dragonfly> INCR mylist\n  (error) ERR value is not an integer or out of range\n  ```\n  \n- Not realizing that `INCR` only creates keys as integer strings when they don't exist. \n  If you want to manipulate more complex data types, use other commands like `INCRBYFLOAT` for floats.\n  \n## FAQs\n\n### What happens if the key contains a non-integer value?\n\nYou will get an error. \n`INCR` expects the value at `key` to be a valid integer or an integer-convertible string (e.g., \"10\").\n  \n### Will `INCR` work with floating-point numbers?\n\nNo, `INCR` is meant for integer manipulation only. \nFor floating-point values, use the `INCRBYFLOAT` command, which is designed specifically for that purpose.\n\n### What happens if the key does not exist?\n\nIf the key does not exist, `INCR` creates the key with a value of `0`, and then increments it by `1`.\nSo the first call to `INCR` will result in the value `1`.",
    "tag": "Redis"
  }
]
